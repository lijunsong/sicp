(load "lisp1-global-env.scm")
(load "../utils.scm")

(define (lookup sym env)
  (begin
    (if (pair? env)
             (if (eq? sym (caar env))
                 (cdar env)
                 (lookup sym (cdr env)))
             (error 'lookup "No such binding" sym env))))

(define empty-begin 813)
(define (eprogn exps env)
  (begin (print "eprogn: " exps)
         (cond ((null? exps) empty-begin)
               ;; important!
               ((null? (cdr exps))
                (evaluate (car exps) env))
               (else
                (begin
                  (evaluate (car exps) env)
                  (eprogn (cdr exps) env))))))

;; (define (eprogn exps env)
;;   (begin (print "eprogn: " exps)
;;          (if (pair? exps)
;;              (if (pair? (cdr exps))
;;                  (begin (evaluate (car exps) env)
;;                         (eprogn (cdr exps) env))
;;                  (evaluate (car exps) env))
;;              empty-begin)))

(define (update! id env val)
  (cond ((null? env)
         (error 'update! "No such binding: ~s" id))
        ((eq? id (caar env))
         (begin
           (set-cdr! (car env) val) 
           val))
        (else
         (update! id (cdr env) val))))

(define (evlis exps env)
  (cond ((null? exps) '())
        (else
         (cons (evaluate (car exps) env)
               (evlis (cdr exps) env)))))

(define (extend env ids vals)
  (cond ((null? ids) env)
        (else
         (cons (cons (car ids) (car vals))
               (extend env (cdr ids) (cdr vals))))))

(define (make-function args body env)
  (lambda (vals)
    (eprogn body (extend env args vals))))

(define (invoke f args)
  (begin (print "invoke: " f " with args: " args)
         (if (procedure? f)
             (f args)
             (error 'evaluate "Not a function ~s" f))))

(define (evaluate e env)
  (if (not (pair? e))
      (cond ((symbol? e) (lookup e env))
            ((or (number? e)
                 (string? e)
                 (char? e)
                 (boolean? e)  
                 (vector e))
             e)
            (else (error "Can't evaluate the expression" e)))
      (case (car e)
        ((quote) (cdr e))
        ((if) (if (not (eq? (evaluate (cadr e) env) the-false-value))
                  (evaluate (caddr e) env)
                  (evaluate (cadddr e) env)))
        ((begin) (eprogn (cdr e) env))
        ((set!)
         (update! (cadr e) env (evaluate (caddr e) env)))
        ((lambda) (make-function (cadr e) (cddr e) env))
        (else
         (invoke (evaluate (car e) env)
                 (evlis (cdr e) env))))))

(define (tracer e env)
  (if (not (pair? e))
      (cond ((symbol? e) (lookup e env))
            ((or (number? e)
                 (string? e)
                 (char? e)
                 (boolean? e)  
                 (vector e))
             e)
            (else (error "Can't tracer the expression" e)))
      (case (car e)
        ((quote) (cdr e))
        ((if) (if (not (eq? (tracer (cadr e) env) the-false-value))
                  (tracer (caddr e) env)
                  (tracer (cadddr e) env)))
        ((begin) (eprogn (cdr e) env))
        ((set!)
         (update! (cadr e) env (tracer (caddr e) env)))
        ((lambda) (make-function (cadr e) (cddr e) env))
        (else
         (let ((vals (evlis (cdr e) env)))
           (begin
             (display "Call:")
             (display (car e))
             (display " -- ")
             (display (cdr e))
             (display " -- ")
             (display vals)
             (invoke (tracer (car e) env)
                     vals)))))))

(define (chapter1-tracer)
  (define (toplevel)
    (let ((s (read)))
      (cond ((eq? s 'exit)
             (display "quit")
             (newline))
            (else 
             (display (tracer s env.global))
             (newline)
             (toplevel)))))
  (toplevel))


(define (chapter1-scheme)
  (define (toplevel)
    (let ((s (read)))
      (cond ((eq? s 'exit)
             (display "quit")
             (newline))
            (else 
             (display (evaluate s env.global))
             (newline)
             (toplevel)))))
  (toplevel))
